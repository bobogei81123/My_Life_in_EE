\documentclass[12pt, a4paper]{article}

%%%%%%%%%%%%%%%紙張大小設定%%%%%%%%%%%%%%%
% \paperwidth=65cm
% \paperheight=160cm

%%%%%%%%%%%%%%%引入Package%%%%%%%%%%%%%%%
\usepackage[top=2cm, bottom=3cm, left=2cm, right=2cm]{geometry} % 上下左右距離邊緣2cm
\usepackage[fleqn]{amsmath}
\usepackage{mathtools,amsthm,amssymb} % 引入 AMS 數學環境
\usepackage{yhmath}     % math symbol
\usepackage{graphicx}   % 圖形插入用
\usepackage{fontspec}   % 加這個就可以設定字體
\usepackage{type1cm}    % 設定fontsize用
\usepackage{titlesec}   % 設定section等的字體
\usepackage{titling}    % 加強 title 功能
\usepackage{fancyhdr}   % 頁首頁尾
\usepackage{tabularx}   % 加強版 table
\usepackage[square, comma, numbers, super, sort&compress]{natbib}
% cite加強版
\usepackage[unicode=true, pdfborder={0 0 0}, bookmarksdepth=-1]{hyperref}
% ref加強版
\usepackage[usenames, dvipsnames]{color}  % 可以使用顏色
\usepackage[shortlabels]{enumitem}  % 加強版enumerate
\usepackage{xpatch}
\usepackage{haskell}

% \usepackage{soul}       % highlight
% \usepackage{ulem}       % 字加裝飾
% \usepackage{wrapfig}     % 文繞圖
\usepackage{floatflt}    % 浮動 figure
\usepackage{float}       % 浮動環境
\usepackage{caption}    % caption 增強
\usepackage{subcaption}    % subfigures
% \usepackage{setspace}    % 控制空行
% \usepackage{mdframed}   % 可以加文字方框
\usepackage{multicol}   % 多欄
\usepackage{siunitx}      % SI unit
\usepackage{indentfirst}
% \usepackage{dsfont}     % more mathbb

%%%%%%%%%%%%%%%%%%%TikZ%%%%%%%%%%%%%%%%%%%%%%
% \usepackage{tikz}

%%%%%%%%%%%%%%中文 Environment%%%%%%%%%%%%%%%
\usepackage[CheckSingle, CJKmath]{xeCJK}  % xelatex 中文
\usepackage{CJKulem} % 中文字裝飾
\setCJKmainfont[BoldFont=cwTeX Q Hei]{cwTeX Q Ming}
%\setCJKsansfont[BoldFont=WenQuanYi Zen Hei]{AR PL UMing TW MBE}
%\setCJKmonofont[BoldFont=WenQuanYi Zen Hei]{AR PL UMing TW MBE}
% 設定中文為系統上的字型，而英文不去更動，使用原TeX字型

% \XeTeXlinebreaklocale "zh"             %這兩行一定要加，中文才能自動換行
% \XeTeXlinebreakskip = 0pt plus 1pt     %這兩行一定要加，中文才能自動換行

%%%%%%%%%%%%%%%字體大小設定%%%%%%%%%%%%%%%
%\def\normalsize{\fontsize{14}{21}\selectfont}
% \def\large{\fontsize{40}{60}\selectfont}
% \def\Large{\fontsize{50}{75}\selectfont}
% \def\LARGE{\fontsize{90}{20}\selectfont}
% \def\huge{\fontsize{34}{51}\selectfont}
% \def\Huge{\fontsize{38}{57}\selectfont}

%%%%%%%%%%%%%%%Theme Input%%%%%%%%%%%%%%%%
% \input{themes/chapter/neat}
% \input{themes/env/problist}

%%%%%%%%%%%titlesec settings%%%%%%%%%%%%%%
% \titleformat{\chapter}{\bf\Huge}
% {\arabic{section}}{0em}{}
% \titleformat{\section}{\centering\Large}
% {\arabic{section}}{0em}{}
% \titleformat{\subsection}{\large}
% {\arabic{subsection}}{0em}{}
% \titleformat{\subsubsection}{\bf\normalsize}
% {\arabic{subsubsection}}{0em}{}
% \titleformat{command}[shape]{format}{label}
% {編號與標題距離}{before}[after]

%%%%%%%%%%%%variable settings%%%%%%%%%%%%%%
% \numberwithin{equation}{section}
% \setcounter{secnumdepth}{4}  %章節標號深度
% \setcounter{tocdepth}{1}  %目錄深度
% \graphicspath{{images/}}  % 搜尋圖片目錄

%%%%%%%%%%%%%%%頁面設定%%%%%%%%%%%%%%%
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}
\setlength{\headheight}{15pt}  %with titling
\setlength{\droptitle}{-1.5cm} %title 與上緣的間距
\usepackage{parskip}
\parindent=0pt %設定縮排的距離
\parskip=1ex  %設定行距
% \pagestyle{empty}  % empty: 無頁碼
% \pagestyle{fancy}  % fancy: fancyhdr

% use with fancygdr
% \lhead{\leftmark}
% \chead{}
% \rhead{}
% \lfoot{}
% \cfoot{}
% \rfoot{\thepage}
% \renewcommand{\headrulewidth}{0.4pt}
% \renewcommand{\footrulewidth}{0.4pt}

% \fancypagestyle{firststyle}
% {
% \fancyhf{}
% \fancyfoot[C]{\footnotesize Page \thepage\ of \pageref{LastPage}}
% \renewcommand{\headrule}{\rule{\textwidth}{\headrulewidth}}
% }

%%%%%%%%%%%%%%%重定義一些command%%%%%%%%%%%%%%%
% \renewcommand{\contentsname}{目錄}  %設定目錄的標題名稱
% \renewcommand{\refname}{References}  %設定參考資料的標題名稱
\renewcommand{\abstractname}{\LARGE Abstract} %設定摘要的標題名稱
\newcommand{\infig}[3]{
  \begin{figure}[H]
    \centering
    \includegraphics[#3]{#1}
    \caption{\label{fig:mres}#2}
  \end{figure}%
}

%%%%%%%%%%%%%%%特殊功能函數符號設定%%%%%%%%%%%%%%%
% \newcommand{\citet}[1]{\textsuperscript{\cite{#1}}}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\norm}{\lVert}{\rVert}
\DeclarePairedDelimiter{\inpd}{\langle}{\rangle} % inner product
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclareMathOperator{\adj}{adj}
\DeclareMathOperator{\sech}{sech}
\DeclareMathOperator{\csch}{csch}
\DeclareMathOperator{\arcsec}{arcsec}
\DeclareMathOperator{\arccot}{arccot}
\DeclareMathOperator{\arccsc}{arccsc}
\DeclareMathOperator{\arccosh}{arccosh}
\DeclareMathOperator{\arcsinh}{arcsinh}
\DeclareMathOperator{\arctanh}{arctanh}
\DeclareMathOperator{\arcsech}{arcsech}
\DeclareMathOperator{\arccsch}{arccsch}
\DeclareMathOperator{\arccoth}{arccoth}
\newcommand{\np}[1]{\\[{#1}] \indent}
\newcommand{\transpose}[1]{{#1}^\mathrm{T}}
%%%% Geometry Symbol %%%%
\newcommand{\degree}{^\circ}
\newcommand{\Arc}[1]{\wideparen{{#1}}}
\newcommand{\Line}[1]{\overleftrightarrow{{#1}}}
\newcommand{\Ray}[1]{\overrightarrow{{#1}}}
\newcommand{\Segment}[1]{\overline{{#1}}}

\newcommand{\opord}{\operatorname{\mathcal{O}}}
\newcommand{\ord}[1]{\opord\left(#1\right)}

%%%%%%%%%%%%%%%證明、結論、定義等等的環境%%%%%%%%%%%%%%%
%\renewcommand{\proofname}{\bf proof:} %修改Proof 標頭
\newtheoremstyle{mystyle}% 自定義Style
{6pt}{15pt}%       上下間距
{}%               內文字體
{}%               縮排
{\bf}%            標頭字體
{.}%              標頭後標點
{1em}%            內文與標頭距離
{}%               Theorem head spec (can be left empty, meaning 'normal')

% 改用粗體，預設 remark style 是斜體
%\theoremstyle{mystyle} % 定理環境Style
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{定義}
\newtheorem{formula}{公式}
\newtheorem{condition}{條件}
\newtheorem{supposition}{假設}
\newtheorem{conclusion}{結論}
\newtheorem{lemma}{引理}
\newtheorem{property}{性質}

\begin{document}
\setcounter{section}{5}
\subsection{Quick sort}
The quick sort algorithm is described in the following.
\newcommand\xs{\mathit{xs}}
\newcommand\ys{\mathit{ys}}
\newcommand\pv{\mathit{pv}}
\[
  \begin{array}{lcl}
    \mathtt{quickSort} & :: & \text{Ord } \alpha \Rightarrow [\alpha] \to [\alpha] \\
   \mathtt{quickSort} \  [\,] & = & [\,] \\
   \mathtt{quickSort} \  \xs & = & 
   (\mathtt{quickSort} \ A) \ \texttt{++}\ C \ \texttt{++}\ (\mathtt{quickSort} \ B) \\
    \hspace*{30pt} \text{\bf where} & \multicolumn{2}{l}{
      \begin{array}[t]{lcl}
        \pv & = & \mathtt{pivot} \ \xs \\
        A & = & \mathtt{filter} \ (< \,\pv) \ \xs \\
        B & = & \mathtt{filter} \ (> \,\pv) \ \xs \\
        C & = & \mathtt{filter} \ (= \,\pv) \ \xs \\
      \end{array}
    }
  \end{array}
\]

\begin{theorem}
The average and worse time complexity is $\ord{n \log n}$ which the later required the median 
of medians (See Section \ref{mom}).
\end{theorem}
\begin{proof}
  Since with the median of medians, finding a median cost $\ord{n}$. And if we use median 
  as the pivot, the recursive formula is 
  \[ T(n) = 2T(n/2) + \ord{n} \implies T(n) \in \ord{n}. \]
\end{proof}

\subsection{Merge sort}
The merge sort algorithm is described in the following.
\[
  \begin{array}{lcl}
    \mathtt{mergeSort} & :: & \text{Ord } \alpha \Rightarrow [\alpha] \to [\alpha] \\
   \mathtt{mergeSort} \  [\,] & = & [\,] \\
   \mathtt{mergeSort} \  [x] & = & [x] \\
   \mathtt{mergeSort} \  \xs & = & \mathtt{mergeTwoSorted} \  
    (\mathtt{firstHalf} \  \xs) \  (\mathtt{secondHalf} \  \xs)
  \end{array}
\]
Where \texttt{firstHalf} and \texttt{secondHalf} cut the list into first $\floor{n/2}$ and 
the remains. Now if we could preform \texttt{mergeTwoSorted} in $\ord{n}$, then the 
time complexity is $T(n) = 2T(n/2) + \Ord{n}$ which yields $T(n) = \ord{n \log n}$.

Actually, there is a clever way to do it.
\[
  \begin{array}{lcl}
    \mathtt{mergeTwoSorted} & :: & \text{Ord } \alpha \Rightarrow [\alpha] \to [\alpha] \to [\alpha] \\
    \mathtt{mergeTwoSorted} \  [\,] \  \ys & = & \ys \\
    \mathtt{mergeTwoSorted} \  \xs \  [\,] & = & \xs \\
    \mathtt{mergeTwoSorted} \  (x:\xs) \  (y:\ys) & & \\
    \hspace*{80pt} | \ x \leq y & = & x : \mathtt{mergeTwoSorted} \ \xs \ (y:\ys) \\
    \hspace*{80pt} | \ \text{\bf otherwise} & = & y : \mathtt{mergeTwoSorted} \ (x:\xs) \ \ys \\
  \end{array}
\]

\subsection{Time complexity of comparison sorting}
\begin{theorem}
For comparison algorithms (i.e. algorithms which only assume the elements in the list is 
comparable), the average time complexity has a lower bound $\ord{n \log n}$.
\end{theorem}


\begin{proof}
  Assuming that every elements in the list is different. 

  Let $P$ be the original list, and $P'$ be the list after sorting. To sort the list
  is equal to decide the permutation $\sigma$ such that $P' = \sigma P$.
  There are $n!$ of such permutation, but exactly one satisfied the equality.

  Every time, we could only compare two elements $x, y$ and get two outcomes,
  either $x > y$ or $x < y$. If we do comparison $m$ times, there are $2^m$
  different outcomes. Base on these information, we have to decide $\sigma$. That is, 
  we could imagine that our algorithm is a function $f = (\alpha_1, \alpha_2, \cdots, \alpha_m) \to \sigma$
  where $\alpha_i$ is the results of the $i$-th comparison. The domain of a function must be larger
  than the image, so $2^m \geq n! \implies m \geq \ord{n \log n}$
\end{proof}

\subsection{Order Statistics}
\subsubsection{$k$-th element}
The following function $\mathtt{select}(\xs, k)$ returns the $k$-th element (in $0$-base) in the list $\xs$.

\[
  \begin{array}{lcl}
    \mathtt{select} & :: & \text{Ord } \alpha \Rightarrow [\alpha] \to \mathbb{N} \to \alpha \\
    \mathtt{select} \ [x] \ 1 & = & x \\
    \mathtt{select} \ \xs \ k & & \\
    \hspace*{30pt} | \ k < m    & = & \mathtt{select} \ A \ k \\
    \hspace*{30pt} | \ \text{\bf otherwise}    & = & \mathtt{select} \ B \ (k - m) \\
    \hspace*{30pt} \text{\bf where} & \multicolumn{2}{l}{
      \begin{array}[t]{lcl}
        \pv & = & \mathtt{pivot} \ \xs \\
        A & = & \mathtt{filter} \ (< \,\pv) \ \xs \\
        B & = & \mathtt{filter} \ (\geq \,\pv) \ \xs \\
        m & = & \mathtt{length} \ A
      \end{array}
    }
  \end{array}
\]

\begin{theorem}
  If $\mathtt{pivot}$ randomly choose a pivot, the algorithm above has average time complexity $\ord{n}$, 
  where $n$ is the length of the list.
\end{theorem}

\begin{proof}
  The recursive formula is 
  \[ T(n) = E[T(\max (\abs{A}, \abs{B}))] + n = 
    \left( \frac{1}{n} \sum_{m=1}^{n-1} T(\max(m, n-m-1)) \right) + n  \]
  
  Assume that $T(k) \leq ck$ for some constant $c$ for all $k < n$. Then
  \begin{align*}
    T(n) &= \left( \frac{1}{n} \sum_{m=1}^{n-1} T(\max(m, n-m-1)) \right) + n \  
    \approx \left( \frac{2}{n} \sum_{m=\ceil{n/2}}^{n-1} T(m) \right) + n \\
    &\leq \left( \frac{2}{n} \sum_{m=\ceil{n/2}}^{n-1} cm \right) + n \ 
    \leq \frac{2}{n} \frac{3cn^2}{8} + n = \frac{3c + 4}{4} n
  \end{align*}
  Choose $c \geq 4$ and hence $(3c+4)/4 \leq c$ and by induction the proof is complete.
\end{proof}

\subsubsection{Median of medians} \label{mom}
If we slightly change how we choose the pivot in the algorithm to 
\[
  \begin{array}{lcl}
    \mathtt{select} \ \xs \ k & = & x \\
    \hspace*{30pt} k < m    & = & \mathtt{select} \ A \ k \\
    \hspace*{30pt} \text{\bf otherwise}    & = & \mathtt{select} \ B \ (k-m) \\
    \hspace*{30pt} \text{\bf where} & \multicolumn{2}{l}{
      \begin{array}[t]{lcl}
        \mathit{mds} & = & \mathtt{map} \ \mathtt{getMedianOf5} \ (\mathtt{chunksOf} \ 5 \ \xs) \\
        \pv & = & \mathtt{select} \ \xs \ \floor{(\texttt{length} \ \mathit{mds})/2}  \\
        A & = & \mathtt{filter} \ (< \,\pv) \ \xs \\
        B & = & \mathtt{filter} \ (\geq \,\pv) \ \xs \\
        m & = & \mathtt{length} \ A
      \end{array}
    }
  \end{array}
\]
Where $(\mathtt{chunksOf} \ 5)$ groups every five elements into a chunk. The method is so called ``Median 
of medians".


\begin{theorem} \hfill
  \begin{enumerate}
    \item $\pv$ would be greater than at least $1/4$ elements, and less than at least $1/4$
      elements in $\mathit{mds}$.
    \item The modified algorithm has a worse time complexity $\ord{n}$.
  \end{enumerate}
\end{theorem}

\begin{proof}
  The length of $\mathit{mds}$ is $\floor{n/2}$.
  Since $\pv$ is the median of $\mathit{mds}$, $\pv$ is greater than $\floor{n/10}$ elements
  in $\mathit{mds}$. Since these element are the median in the chunk it belongs, each 
  of them is not less than $3$ elements in its chunk, and hence $\pv$ is greater than 
  $\floor{n/10} \cdot 3 \geq n/4$ elements. Similarly $\pv$ is less than $n/4$ elements.

  The recursive formula of $T(n)$ in the worse case is
  \[ T(n) = T(n/5) + T(3n/4) + n \]

  Assume that $T(k) \leq ck$ for some constant $c$ for all $k < n$. Then
  \begin{align*}
    T(n) \leq \frac{cn}{5} + \frac{3cn}{4} + n = \frac{19c + 20}{20} n
  \end{align*}
  Choose $c \geq 20$ and then $(19c+20)/20 \leq c$. By induction the proof is complete.

\end{proof}

\end{document}
